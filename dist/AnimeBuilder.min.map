{"version":3,"sources":["AnimeBuilder.js"],"names":["AnimeBuilder","constructor","animeConfig","animeRules","animeBuilderId","totalDuration","tempDur","propDurationMap","Map","DEFAULT_VALUES","scaleX","scaleY","add","propertySet","propKey","propVal","Object","entries","diffDur","_getDurationDiff","_addPlaceholderProp","_addToPropDurMap","hasOwnProperty","forEach","val","push","duration","slice","durSum","_getDurationPropValSum","_getHighestDurFromMap","_calcDurSum","property","sumDurObj","reduce","p1","p2","_getCurrentDuration","has","get","propVals","durObj","v1","v2","undefined","Error","value","_checkSumEquality","compareDur","durationMap","highestDur","values","_updatePropDurMap","propDurationSum","set","onUpdate","callback","update","extractAnimeRules","getDefaultValues","getDefaultValue","generateAnime","assign"],"mappings":";AAEkC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAFlC,IAAA,EAAA,EAAA,QAAA,YAEkC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAnB,MAAMA,EACnBC,YAAYC,EAAc,IACnBC,KAAAA,WAAa,CAChBC,gBAAgB,GAEbF,KAAAA,YAAcA,EACdG,KAAAA,cAAgB,EAGhBC,KAAAA,QAAU,EACVC,KAAAA,gBAAkB,IAAIC,IACtBC,KAAAA,eAAiB,CACpBC,OAAQ,EACRC,OAAQ,GAIZC,IAAIC,GAMG,IAAA,IAAKC,EAASC,KAAYC,OAAOC,QAAQJ,GAAc,CAItDK,IAAAA,EAAU,KAAKC,iBAAiBL,GAQhC,GALAI,EAAU,IACPE,KAAAA,oBAAoBN,EAASI,GAC7BG,KAAAA,iBAAiBP,EAASI,IAG5B,KAAKf,WAAWmB,eAAeR,GAKlCC,EAAQQ,QAASC,IACVrB,KAAAA,WAAWW,GAASW,KAAKD,GACzBH,KAAAA,iBAAiBP,EAASU,EAAIE,gBAPO,CACvCvB,KAAAA,WAAWW,GAAWC,EAAQY,MAAM,GACrCC,IAAAA,EAAS,KAAKC,uBAAuBd,EAAQY,MAAM,IAClDN,KAAAA,iBAAiBP,EAASc,IAa5B,OAFFvB,KAAAA,cAAgB,KAAKyB,sBAAsB,KAAKvB,iBAE9C,KAOTwB,YAAYC,GASHC,OARU,KAAK9B,WAAW6B,GAENE,OAAO,CAACC,EAAIC,KAG9B,MAAA,CAACV,UAFIS,EAAGT,SAAYS,EAAGT,SAAW,IAC7BU,EAAGV,SAAYU,EAAGV,SAAW,KAExC,GAEcA,SAGnBW,oBAAoBL,GACf,OAAC,KAAKzB,gBAAgB+B,IAAIN,GACrB,KAAKzB,gBAAgBgC,IAAIP,GADgB,EAQnDH,uBAAuBW,GAMdC,OALMD,EAASN,OAAO,CAACQ,EAAIC,KAC5B,GAAgBC,OAAfF,EAAGhB,UAAyCkB,OAAfD,EAAGjB,SAA+B,MAAA,IAAImB,sDAAsDL,KACvH,MAAA,CAACd,SAAUgB,EAAGhB,SAAWiB,EAAGjB,WAClC,CAACA,SAAU,IAEAA,SAGhBP,iBAAiBa,GACXd,IAAAA,EAAU,KAAKb,cAAgB,KAAKgC,oBAAoBL,GACxDd,GAAAA,EAAU,EAAW,MAAA,IAAI2B,kBAAkBb,yGAExCd,OAAAA,EAUTE,oBAAoBY,EAAUN,GACKkB,MAA7B,KAAKzC,WAAW6B,KACb7B,KAAAA,WAAW6B,GAAY,IAGzB7B,KAAAA,WAAW6B,GAAUP,KAAK,CAC7BqB,MAAO,MACPpB,SAAUA,IAYdqB,kBAAkBlC,GACZmC,IAAAA,GAAc,EAEb,IAAA,IAAKlC,EAAS0B,KAAaxB,OAAOC,QAAQJ,GACzCmC,GAAAA,EAAa,EACfA,EAAa,KAAKnB,uBAAuBW,QAErCQ,GAAAA,IAAe,KAAKnB,uBAAuBW,GACtC,OAAA,EAKN,OAAA,EAOTV,sBAAsBmB,GAChBC,IAAAA,EAAa,EAEZ,IAAA,IAAIxB,KAAYuB,EAAYE,SAC3BzB,EAAWwB,IAAcA,EAAaxB,GAGrCwB,OAAAA,EAGTE,kBAAkBpB,GACZ,IAACA,EAAkB,MAAA,IAAIa,kBAAkBb,kBAEzCqB,IAAAA,EAAkB,KAAKtB,YAAYC,GACnCqB,EAAkB,KAAK/C,UAAgBA,KAAAA,QAAU+C,GAEhDhC,KAAAA,iBAAiBW,EAAUqB,GAGlChC,iBAAiBW,EAAUN,GACrB,KAAKnB,gBAAgB+B,IAAIN,GACrBzB,KAAAA,gBAAgB+C,IAAItB,EAAU,KAAKzB,gBAAgBgC,IAAIP,GAAYN,GAItEnB,KAAAA,gBAAgB+C,IAAItB,EAAUN,GAIrC6B,SAASC,GAGA,OAFFtD,KAAAA,YAAYuD,OAASD,EAEnB,KAITE,oBACS,OAAA,KAAKvD,WAGdwD,mBACS,OAAA,KAAKlD,eAGdmD,gBAAgB5B,GACV,OAAA,KAAKvB,eAAeuB,GACf,KAAKvB,eAAeuB,GAGtB,EAGT6B,gBACS,OAAA,EAAM7C,EAAAA,SAAAA,OAAO8C,OAAO,KAAK5D,YAAa,KAAKC,cAlMpB,QAAA,QAAA","file":"AnimeBuilder.min.map","sourceRoot":"..\\src\\js","sourcesContent":["import anime from 'animejs';\r\n\r\nexport default class AnimeBuilder {\r\n  constructor(animeConfig = {}) {\r\n    this.animeRules = {\r\n      animeBuilderId: true               // Identifies this as a ruleset built by an AnimeBuilder\r\n    };\r\n    this.animeConfig = animeConfig;\r\n    this.totalDuration = 0;\r\n    // This will be updated more often than totalDuration.\r\n    // totalduration is read too often so it needs a temp storage\r\n    this.tempDur = 0;\r\n    this.propDurationMap = new Map();\r\n    this.DEFAULT_VALUES = {\r\n      scaleX: 1,\r\n      scaleY: 1\r\n    }\r\n  }\r\n  \r\n  add(propertySet) {\r\n    \r\n    // TODO get this to work with extracted properties, animeBuilders and animeObjects\r\n    \r\n    //if (!this._checkSumEquality(propertySet)) { throw new Error(`Each property in the added property-set needs to have equal total durations: ${JSON.stringify([...this.propDurationMap])} `)};\r\n\r\n    for (let [propKey, propVal] of Object.entries(propertySet)) {\r\n\r\n      // After all props have been added\r\n\r\n      let diffDur = this._getDurationDiff(propKey);\r\n\r\n      // Add placeholder if there is a duration difference\r\n      if (diffDur > 0) {\r\n        this._addPlaceholderProp(propKey, diffDur);\r\n        this._addToPropDurMap(propKey, diffDur);\r\n      };\r\n\r\n      if (!this.animeRules.hasOwnProperty(propKey)) {\r\n        this.animeRules[propKey] = propVal.slice(0);\r\n        let durSum = this._getDurationPropValSum(propVal.slice(0));\r\n        this._addToPropDurMap(propKey, durSum);\r\n      } else {\r\n        propVal.forEach((val) => {\r\n          this.animeRules[propKey].push(val);\r\n          this._addToPropDurMap(propKey, val.duration);\r\n        });\r\n      }\r\n\r\n      //this._updatePropDurMap(propKey);\r\n    }\r\n\r\n    this.totalDuration = this._getHighestDurFromMap(this.propDurationMap);\r\n    \r\n    return this;\r\n  }\r\n\r\n/**\r\n * Calculates the duration sum of a property (translateX, translateY, scaleX, etc...)\r\n * @param {*} property - animation css property such as (translateX, translateY, scaleX, etc...)\r\n */\r\n  _calcDurSum(property) {\r\n    let propValArr = this.animeRules[property];\r\n\r\n    let sumDurObj = propValArr.reduce((p1, p2) => {\r\n      let dur1 = (p1.duration) ? p1.duration : 0;\r\n      let dur2 = (p2.duration) ? p2.duration : 0;\r\n      return {duration: dur1 + dur2};\r\n    }, 0);\r\n\r\n    return sumDurObj.duration;\r\n  }\r\n\r\n  _getCurrentDuration(property) {\r\n    if(!this.propDurationMap.has(property)) { return 0 };\r\n     return this.propDurationMap.get(property);\r\n  }\r\n\r\n  /**\r\n   * Sums up all of the duration of an array of prop values\r\n   * @param {Array} propVals - An array of property values\r\n   */\r\n  _getDurationPropValSum(propVals) {\r\n    let durObj = propVals.reduce((v1, v2) => {\r\n      if (!v1.duration == undefined || !v2.duration == undefined) { throw new Error(`All propvals must have a duration. Propvals: ${propVals}`)}\r\n      return {duration: v1.duration + v2.duration};\r\n    }, {duration: 0});\r\n\r\n    return durObj.duration\r\n  }\r\n\r\n  _getDurationDiff(property) {\r\n    let diffDur = this.totalDuration - this._getCurrentDuration(property);\r\n    if (diffDur < 0) { throw new Error(`Property ${property} has a negitive duration difference, which is not allowed. Please check all added property durations`)}\r\n\r\n    return diffDur;\r\n  }\r\n\r\n  /**\r\n   * Adds a new propertyValue with the inputed duration.\r\n   * The placeholder properties value will either be the current\r\n   * value, or if no current value exists, the default value.\r\n   * @param {*} property - The property to add the new placeholder to\r\n   * @param {Number} duration - The duration of that placeholder property\r\n   */\r\n  _addPlaceholderProp(property, duration) {\r\n    if (this.animeRules[property] == undefined) {\r\n      this.animeRules[property] = [];\r\n    }\r\n\r\n    this.animeRules[property].push({\r\n      value: '*=1',\r\n      duration: duration\r\n    });\r\n  }\r\n \r\n  /**\r\n   * Checks if the sum of each property's duration values\r\n   * is equivalent to each other. \r\n   * \r\n   * returns true if they are all are equal\r\n   * @param {Object} propertySet - Object of 1 to many properties\r\n   * @return {boolean}\r\n   */\r\n  _checkSumEquality(propertySet) {\r\n    let compareDur = -1;\r\n\r\n    for (let [propKey, propVals] of Object.entries(propertySet)) {   \r\n      if (compareDur < 0) {\r\n        compareDur = this._getDurationPropValSum(propVals);\r\n      } else {\r\n        if (compareDur !== this._getDurationPropValSum(propVals)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {*} durationMap - a propDurationMap, map linking props to their total durations\r\n   */\r\n  _getHighestDurFromMap(durationMap) {\r\n    let highestDur = 0;\r\n\r\n    for (let duration of durationMap.values()) {   \r\n      if (duration > highestDur) { highestDur = duration }\r\n    }\r\n\r\n    return highestDur;\r\n  }\r\n\r\n  _updatePropDurMap(property) {\r\n    if (!property) { throw new Error(`Property ${property} is undefined`)}\r\n\r\n    let propDurationSum = this._calcDurSum(property);\r\n    if (propDurationSum > this.tempDur) { this.tempDur = propDurationSum };\r\n\r\n    this._addToPropDurMap(property, propDurationSum);\r\n  }\r\n\r\n  _addToPropDurMap(property, duration) {\r\n    if (this.propDurationMap.has(property)) {\r\n       this.propDurationMap.set(property, this.propDurationMap.get(property) + duration);\r\n       return;\r\n    }\r\n\r\n    this.propDurationMap.set(property, duration);\r\n  }\r\n\r\n  // adds functions that happens on every animation update\r\n  onUpdate(callback) {\r\n    this.animeConfig.update = callback;\r\n    \r\n    return this;\r\n  }\r\n  \r\n  // Returns the raw pre generated ruleset\r\n  extractAnimeRules() {\r\n    return this.animeRules;\r\n  }\r\n\r\n  getDefaultValues() {\r\n    return this.DEFAULT_VALUES;\r\n  }\r\n\r\n  getDefaultValue(property) {\r\n    if (this.DEFAULT_VALUES[property]) {\r\n      return this.DEFAULT_VALUES[property];\r\n    }\r\n\r\n    return 0;\r\n  }\r\n  \r\n  generateAnime() {\r\n    return anime(Object.assign(this.animeConfig, this.animeRules));\r\n  }\r\n}"]}